# 死锁
## 死锁的产生
线程1 获取了A的锁，去申请B的锁
线程2 获取了B的锁，去申请A的锁
现实可能更复杂，本质就是形成了一个环
原因：
获取锁的顺序问题
申请锁是阻塞

## 如何避免死锁
1. 尽量缩小锁范围，不必锁嵌套锁的就不要这样做
2. 保存所有使用A、B对象锁的地方，顺序是一致的
3. 加锁时效，时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。
4. 使用不可变对象，不可以变对象不存在线程安全问题
5. 死锁检测：
a. 保存调用链图，请求锁失败，去检查调用链，发现存在死锁，类似加锁时效处理。退出，随机。
b. 更优异的处理，是随机给线程加上优先级，检查后，发现死锁，释放优先级低线程
6. 更粗暴的做法，ReentrantLock.tryLock()方法(不使用lock())，在一个循环中，如果tryLock()返回失败，那么就释放以及获得的锁，并睡眠一小段时间。这样就打破了死锁的闭环。

# 可重入锁
synchronized 对象头中 "Mark Word"记录线程id及进入次数
ReentrantLock 保存exclusiveOwnerThread(当前执行的线程)，以及AQS的state加减一

# 公平锁、非公平锁
ReentrantLock中实现只是在获取锁的时候，公平锁加入了hasQueuedPredecessors的判断，必须加入队列中有其他线程，必须加入到队列中才可以获取到锁。有个双向的Node链表记录了需要获取锁的线程，unlock()state == 0时候，LockSupport.unpark唤起对应线程

