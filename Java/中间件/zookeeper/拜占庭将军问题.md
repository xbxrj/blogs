 # 拜占庭将军问题
 拜占庭问题，为什么只有leader发起投票。每个人都可以发投票，没有投票都要结合所有人接受情况判断结果，最后还要结合所有投票结果判断最终执行动作。浪费以及麻烦，所以选leader

## 问题描述
拜占庭派出7位将军，去进攻敌对国家。7位将军地理位置相隔较远，只能通过信使交换信息。观察敌对国家情况后，制定共同行动计划。7位将军中存在叛徒，会干扰忠诚将军的判断（和现实中分布式网络环境十分相似，怎么保持数据一致性）。问题来了，怎么保持忠诚将军正确的一致行动？
## 问题分析
上面问题拆解下来就是下面这两点要求：
1. 所有忠诚将军决定行动计划
2. 叛徒将军不能使忠诚将军采取一个坏计划
*这里的正确比较粗暴，人数多的决定就认为是正确的，当忠诚将军进攻和撤退平票的时候，这时的进攻或者撤退都不算坏计划*
一个目前我们唯一能知道的方法：
每个将军通过信使将他的信息广播给每个将军，将军们根据这个信息去判断出行动计划。及协议满足如下两个条件
* 条件1: 每一个忠诚的将军必须获得相同的信息v(1),…,v(n)
* 条件2: 如果第i个将军是忠诚的，那么他所发送的值必须被每个忠诚的将军用作v(i)的值
但因为叛徒的存在，所有条件1不能满足，变化为条件1`
* 条件1`:每一个忠诚的将军使用的v(i)值相同
这样只要解决了下面这个问题，所有忠诚将军最终使用的信息v(1),…,v(n)就是相同的了。
```
问题：一个将军发送信息给其他将军，如果这个将军是忠诚，所有忠诚将军使用的就是的就是这个信息，如果这个将军是叛徒，所有忠诚最后使用的信息是相同的。
```
为了方便描述，Lamport在论文中将这个问题的描述最终变化为，主将给副将发送信息的问题。
```
最终只需所有将军执行一个协议（算法），这个协议可以解决如下问题，那所有的问题都解决了：
IC1.所有忠诚的副将遵守相同的命令。 
IC2.如果主将是忠诚的，那么每个忠诚的副将都服从他发出的命令。
```
## 口头协议
口头协议防止主将叛徒不发送信息，会设置默认行动。
### 不可能的结果 （证明不够准确）
如果将军们只能发出口头信息，那么除非超过三分之二的将军忠诚，否则任何解决办法都不会起作用。口头消息是一个内容完全受到发件人控制的消息，所以一个叛国的发件人可以发送任何可能的消息。及口头协议只可以解决超过3m个将军（3m+1）的问题,m表示最多叛徒数。3个将军中，有一个叛徒的时候这个问题就是无解的。
每个副将获取命令的过程：
1. 接收主将命令
2. 询问其他副将在步骤1的时候接受的命令是什么
证明3m的时候无解：
主将|叛徒，副将1、副将2|忠诚。
步骤1的时候，忠诚副将1收到命令进攻，忠诚副将2收到命令撤退。步骤2的时候忠诚副将1、忠诚副将2收到的都是一个进攻、一个撤退，则无法决策

### 口头协议的解
#### 口头协议定义
```
A1:每个发送的信息都会被正确的传输
A2:信息的接受者知道谁是消息发送者
A3:信息的缺席可以被检查出
```
目的：A1、A2防止叛徒可以干扰两两将军间的通信。A3防止叛徒不发送信息，阻止计划。必须有默认计划，缺席的信息，使用默认计划替代。

#### 口头协议算法
口头协议(Oral Message简称OM)算法OM(m)，解决了至少3m+1个将军时，m个叛徒的解。
**首先说下majority函数**
一组元素（v1，v2 ... vn）半数以上值为v，则majority(v1，v2 ... vn)=v
对于majority(v1,v2…vn)有两种自然的选择：
1.如果存在出现半数以上的元素，它的值就是它，否则值为默认计划。 
2.vi的中位数，假设他们是一组有序集合。
**口头协议算法OM(m):**
```
算法OM(m) 
m=0
(1)主将发送他的值给每个副将 
(2)每个副将使用他从主将那收到的值，如果没有收到则使用默认计划
m>0
(1)主将发送他的值给每个副将
(2)对于任意i，vi代表副将i从主将收到的值，如果没有收到则采用默认计划。副将i扮演算法OM(m-1)中的发令者，并采用该算法将值vi发送给其余的n-2个副将。 
(3)对于任意i以及任意的j!=i，vj是副将i在步骤2中(使用算法OM(m-1))从副将j收到的值，如果他没有收到这样的值，就采用默认计划。副将i采用函数majority(v1,v2…vn-1)的值
```
算法解释：
1. 这个算法是一个递归算法，在OM(m)中需要采用OM(m-1)得到相关结果。m代表的是叛徒数量，从m到0，意味着对于每个将军，需要m+1轮的算法才能完成。
2. 对于m>1，一个副将会向其他副将发送很多独立的消息。必须要有某种方式用来区分这些不同的消息。读者可以验证，如果每个副将i将数字i加入到他在步骤2中发送的值vi的前缀中，所有的混淆之处都可以消除。伴随着递归的展开，算法OM(m-k)可能会被调用(n-1)…(n-k)次来发送由k个副将的数字组成的序列为前缀的值。（原论文中的建议）
3. 利用该算法，可以保证叛徒数量在某一个最大值m（即总将军数量的1/3）之下时，拜占庭将军问题可解。所以改算法需要预设叛徒数
4. 对于任意k<m，在第m-k+1步中OM(k)的vi，都是利用OM(k-1)得来的，即每个将军将会在OM(k-1)中询问其他人，i将军传给他们的是什么，而其他人传递回来的信息则是利用OM(k-2)得到。
说明:为什么是递归算法，因为每个主将、副将都有可能是叛徒，所以获取来的每个值，都需要去询问其他人，他给你发的是什么，然后利用函数majority(v1,v2…vn-1)确认这个值，这样忠诚的将军占大多数的时候，所有忠诚获取的值都是一致的。下面在m=2，n=7的情况下说明(主将忠诚的就不在说明了，这里主要说明主将是叛徒的情况)：
# 图片查考口头协议算法流程（流程图很重要）
解释为什么需要执行m次（主要是考虑主将是叛徒情况下，主将为忠诚一步就可以了，这里OM(m)算法的目的是所有忠诚将军的行动一致）：
OM(m)的时候，每位副将收到主将随机信息，及下面还有m-1个叛徒，再进行一次广播，m-2个叛徒...但m次后，针对每个叛徒信息全部由忠诚的信息决定的，及所有忠诚针对这个叛徒的决定都是一致。再往上反推所有忠诚的决定都是一致的了。如上面：主将发出信息OM(m=2),副将收到的信息不一致。这时候每个副将需要去确定其他人收到的是什么，及OM(m=2-1),这时候每个副将收到其余副将收到的信息，这时候忠诚副将接受的信息除5信息都是一致的了，副将5叛徒的信息又是乱发的。所以再一次发OM(2-2)次，接受其他人5发给你们的是什么信息，这时候再次收到的信息都是忠诚副将发的，所以忠诚副将针对5的行动决定也是一致的。以此类推m个叛徒就需要递归OM(m)算法m次，直至m=0





